<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Clipboard Enhanced with Editing and Partition Support</title>
<style>
  body {
    background-color: #111; /* 어두운 배경 */
    color: #fff; /* 밝은 글씨 */
  }
  .title {
  text-align: left;
  font-size: 12px; /* 글자 크기를 18px로 조정 */
  margin-top: 4px;
  margin-bottom: 4px;
  }

  .copy-text, button, input[type="text"] {
    margin: 5px;
    padding: 5px 10px;
    font-size: 14px;
    background-color: #333; /* 어두운 요소 배경 */
    border: 0px solid #777; /* 어두운 테두리 */
    border-radius: 6px;
    cursor: pointer;
    color: #ddd; /* 어두운 요소 내 글씨 */
  }

  .edit-btn {
      margin: 2px;
      padding: 1px 1px;
      font-size: 10px;
      background-color: #111; /* 어두운 요소 배경 */
      color: #aaa; /* 어두운 요소 내 글씨 */
      border: none; /* 테두리 제거 */
      border-radius: 0px;
      cursor: pointer;
  }

  .delete-btn {
    margin-left: 5px;
    color: #e74c3c; /* 강조된 삭제 버튼 색상 */
    cursor: pointer;
    font-size: 20px;
  }
  #phrasesContainer {
  display: block; /* flex 대신 block 레이아웃 사용 */
  -webkit-column-count: 2; /* Safari/Chrome, 기타 WebKit 기반 브라우저 */
  -moz-column-count: 2; /* Firefox */
  column-count: 2; /* 열의 수 */
  -webkit-column-gap: 20px; /* Safari/Chrome, 기타 WebKit 기반 브라우저 */
  -moz-column-gap: 20px; /* Firefox */
  column-gap: 20px; /* 열 사이의 간격 */
  max-height: 73vh;
  overflow-y: 75vh;
  overflow-x: auto; 
  padding: 10px; /* 컨테이너 안쪽 여백 */
}
  .phrase-container {
    margin: 10px;
    flex-basis: calc(100%); /* Adjusted in JavaScript */
  }
  #feedback, .partition-controls, .file-controls {
    position: fixed;
    font-size: 14px;
    left: 0;
    width: 100%;
    /*background: #222; /* 고정된 요소 배경 */
    text-align: center;
    padding: 5px;
    border-top: 1px solid #444; /* 고정된 요소 테두리 */
  }
  .partition-controls {
    bottom: 80px;
  }
  .file-controls {
    bottom: 30px;
  }
  #feedback {
    bottom: 0px;
  }
  .button-group {
  display: inline-block;
  margin-left: 30px;
  background-color: #222;
  border-radius: 10px;
  margin-right: 0px; /* 오른쪽에 마진을 줘서 그룹 간 간격을 조정 */
}
  .floating-message {
  position: fixed;
  bottom: 20%; /* 화면 하단에서부터의 위치 */
  left: 50%; /* 중앙 정렬을 위한 설정 */
  transform: translateX(-50%); /* 정확한 중앙 정렬을 위한 설정 */
  background-color: #333;
  color: #fff;
  padding: 10px;
  border-radius: 5px;
  display: none; /* 기본적으로는 숨김 처리 */
  z-index: 1000; /* 다른 요소들 위에 표시 */
  }
  button:hover, .copy-text:hover, .edit-btn:hover {
    background-color: #666; /* 호버 시 배경 */
  }
  input[type="text"] {
    color: #ccc; /* 입력 필드 글씨 색상 */
    border: 1px solid #555; /* 입력 필드 테두리 */
  }
</style>
</head>
<body>
<div id="floatingMessage" class="floating-message">복사되었습니다!</div>
<div class="title">LepuTools - Quick Conversation v1.13    |    Q : 누적복사, W : 누적초기화</div>
<input type="text" id="newPhrase" placeholder="자주 쓰는 문구">
<button id="addPhraseButton">추가하기</button>
<div class="button-group">
    <button onclick="exportToFile()">데이터 저장</button>
    <input type="file" id="fileInput" style="display: none;" onchange="importFromFile(event)"/>
    <button id="loadButton">데이터 불러오기</button>
  </div>
<div id="phrasesContainer"></div>
<div id="feedback"></div>
<div class="partition-controls">
  <button onclick="setPartition(2)">II</button>
  <button onclick="setPartition(3)">III</button>
  <button onclick="setPartition(4)">IIII</button>
  <button onclick="setPartition(5)">IIIII</button>
  <button onclick="setPartition(6)">IIIIII</button>
</div>


<div class="file-controls">
  
  <div class="button-group">
    <button id="copyButton">누적 복사</button>
    <button id="resetButton">누적 초기화</button>
</div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  phrases = JSON.parse(localStorage.getItem('phrases') || '[]');
  const lastPartition = localStorage.getItem('lastPartition') || '1';
  document.getElementById('addPhraseButton').addEventListener('click', addPhrase);
  setPartition(lastPartition, false);
  renderPhrases();

  // 공지사항 설정
  const feedback = document.getElementById('feedback');
  feedback.textContent = '자주 쓰는 문구를 추가하고 클릭하면 복사됩니다.'; // 초기 공지사항 텍스트 설정
});

document.getElementById('copyButton').addEventListener('click', function() {
  navigator.clipboard.writeText(accumulatedText.trim()).then(function() {
    console.log('Accumulated text copied to clipboard');

    // 복사 후 feedback 업데이트
    const feedback = document.getElementById('feedback');
    feedback.textContent = '누적 복사 <' + accumulatedText.trim() + '> 복사됨.';
    
    // 누적된 텍스트 초기화 (선택사항)
    accumulatedText = '';
  }).catch(function(err) {
    console.error('Could not copy text to clipboard:', err);
  });

  
});


document.getElementById('loadButton').addEventListener('click', function() {
    document.getElementById('fileInput').click(); // 원래 파일 입력을 트리거
});

// 누적 내용 초기화 버튼 클릭 이벤트 리스너
document.getElementById('resetButton').addEventListener('click', function() {
  accumulatedText = ''; // 누적된 텍스트 초기화
  const feedback = document.getElementById('feedback');
  feedback.textContent = '누적된 내용이 초기화되었습니다.'; // feedback 업데이트
});

document.addEventListener('keydown', function(e) {
  // Q를 눌렀을 때의 조건
  if (e.key === 'q') {
    e.preventDefault();
    
    // 누적된 내용 복사 함수 호출
    navigator.clipboard.writeText(accumulatedText.trim()).then(function() {
      console.log('Accumulated text copied to clipboard');
      // 복사 후 feedback 업데이트
      const feedback = document.getElementById('feedback');
      feedback.textContent = '복사 완료: ' + accumulatedText.trim();
    }).catch(function(err) {
      console.error('Could not copy text to clipboard:', err);
    });
  }

  if (e.key.toLowerCase() === 'w') {
    e.preventDefault(); // 브라우저의 기본 동작 방지
    accumulatedText = ''; // 누적된 텍스트 초기화
    console.log('Accumulated text cleared');

    const feedback = document.getElementById('feedback');
    feedback.textContent = '누적된 내용이 초기화되었습니다.';
  }
});


let phrases = [];
let accumulatedText = ''; // 누적된 텍스트를 저장할 변수 선언

function accumulateText(text) {
  accumulatedText += text + ' '; // 클릭한 슬롯의 텍스트를 누적
  console.log('Accumulated text:', accumulatedText); // 현재까지 누적된 텍스트 확인
}

function copyTextToClipboard(text) {
  navigator.clipboard.writeText(text).then(function() {
    const feedback = document.getElementById('feedback');
    feedback.textContent = `누적됨 : ` + accumulatedText;
    showFloatingMessage(`복사됨 : ${text} `, 3000); // 메시지와 표시 시간(예: 3000ms)
    console.log('Text successfully copied to clipboard');
  }, function(err) {
    console.error('Could not copy text: ', err);
  });
}

function addPhrase() {
  const phraseInput = document.getElementById('newPhrase');
  const phrase = phraseInput.value.trim();
  if (phrase) {
    phrases.push(phrase);
    phraseInput.value = ''; // Clear input after adding
    savePhrases();
    renderPhrases();
  } else {
    alert("자주 쓰는 문구를 입력하세요");
  }
}


function editPhrase(index) {
  const newPhrase = prompt('Edit your phrase:', phrases[index]);
  if (newPhrase !== null && newPhrase !== '') {
    phrases[index] = newPhrase;
    savePhrases();
    renderPhrases();
  }
}

function deletePhrase(index) {
  const confirmDelete = confirm("정말로 삭제합니까?");
  if (confirmDelete) {
    phrases.splice(index, 1);
    savePhrases();
    renderPhrases();
  }
}

function savePhrases() {
  localStorage.setItem('phrases', JSON.stringify(phrases));
}

function setPartition(partition, save = true) {
  const container = document.getElementById('phrasesContainer');

  // 열 수 설정
  container.style.WebkitColumnCount = partition; // WebKit/Chrome/Safari
  container.style.MozColumnCount = partition; // Firefox
  container.style.columnCount = partition; // 일반

  if (save) {
    localStorage.setItem('lastPartition', partition);
  }
}

function exportToFile() {
  const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(phrases));
  const dlAnchorElem = document.createElement('a');
  dlAnchorElem.setAttribute("href", dataStr);
  dlAnchorElem.setAttribute("download", "MyQuickConversation.json");
  document.body.appendChild(dlAnchorElem); // Firefox에서 필요할 수 있음
  dlAnchorElem.click();
  dlAnchorElem.remove(); // 생성된 요소를 제거
}

function importFromFile(event) {
  const fileReader = new FileReader();
  fileReader.onload = function(e) {
    phrases = JSON.parse(e.target.result);
    savePhrases();
    renderPhrases();
  };
  fileReader.readAsText(event.target.files[0]);
}

let draggedItemIndex = null; // 드래그된 항목의 인덱스를 저장할 변수

function handleDragStart(e) {
  draggedItemIndex = parseInt(e.target.getAttribute('data-index')); // 드래그 시작 항목의 인덱스 저장
}

function handleDragOver(e) {
  e.preventDefault(); // 기본 동작을 방지하여 drop 이벤트를 허용
}

function handleDrop(e) {
    e.preventDefault();
    const target = e.target.closest('.phrase-container'); // 가장 가까운 phraseContainer를 찾음
    if (!target) return; // 드랍 대상이 phraseContainer가 아니면 종료
    
    const targetIndex = parseInt(target.getAttribute('data-index'));
    const draggedElement = phrases[draggedItemIndex];
    
    // 드랍 위치가 요소의 중간 지점보다 위인지 아래인지 확인
    const rect = target.getBoundingClientRect();
    const offset = e.clientY - rect.top; // 마우스 위치와 대상 요소 상단 간의 거리
    const middle = rect.height / 2;
    
    // 순서 재배치 로직
    if (offset < middle) {
        // 마우스 위치가 중간 지점보다 위에 있을 경우, 드래그된 요소를 그 위치에 삽입
        if (targetIndex < draggedItemIndex) {
            phrases.splice(draggedItemIndex, 1);
            phrases.splice(targetIndex, 0, draggedElement);
        } else {
            phrases.splice(draggedItemIndex, 1);
            phrases.splice(targetIndex - 1, 0, draggedElement);
        }
    } else {
        // 마우스 위치가 중간 지점보다 아래에 있을 경우
        if (targetIndex < draggedItemIndex) {
            phrases.splice(draggedItemIndex, 1);
            phrases.splice(targetIndex + 1, 0, draggedElement);
        } else {
            phrases.splice(draggedItemIndex, 1);
            phrases.splice(targetIndex, 0, draggedElement);
        }
    }

    savePhrases(); // 변경사항 저장
    renderPhrases(); // 리스트를 다시 렌더링
}


function renderPhrases() {
  const container = document.getElementById('phrasesContainer');
  container.innerHTML = '';
  phrases.forEach((phrase, index) => {


    const phraseEl = document.createElement('span');
    phraseEl.classList.add('copy-text');
    phraseEl.textContent = phrase;
    phraseEl.onclick = function() {
    accumulateText(phrase); // 누적된 텍스트 관리
    copyTextToClipboard(phrase); // 클립보드에 즉시 복사
    };

    const editBtn = document.createElement('button');
    editBtn.classList.add('edit-btn');
    editBtn.textContent = 'Edit';
    editBtn.onclick = function() { editPhrase(index); };
    
    const deleteBtn = document.createElement('span');
    deleteBtn.classList.add('delete-btn');
    deleteBtn.innerHTML = '&times;';
    deleteBtn.onclick = function() { deletePhrase(index); };

    const phraseContainer = document.createElement('div');
    phraseContainer.classList.add('phrase-container');
    phraseContainer.appendChild(phraseEl);
    phraseContainer.appendChild(editBtn);
    phraseContainer.appendChild(deleteBtn);
    
    container.appendChild(phraseContainer);
    phraseContainer.setAttribute('draggable', true); // 드래그 가능하게 설정
    phraseContainer.setAttribute('data-index', index); // 인덱스를 속성으로 추가
    
    phraseContainer.addEventListener('dragstart', handleDragStart);
    phraseContainer.addEventListener('dragover', handleDragOver);
    phraseContainer.addEventListener('drop', handleDrop);
    

  });


}

function showFloatingMessage(message, duration = 3000) {
  const floatingMessage = document.getElementById('floatingMessage');
  floatingMessage.textContent = message; // 메시지 설정
  floatingMessage.style.display = 'block'; // 메시지 표시

  // 일정 시간(duration) 후에 메시지 숨기기
  setTimeout(() => {
    floatingMessage.style.display = 'none';
  }, duration);
}

</script>
</head>
</html>